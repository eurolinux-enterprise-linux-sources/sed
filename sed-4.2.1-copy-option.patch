From d3832b7d4dd76fa3dc2b6f28be747e8de2b29ad8 Mon Sep 17 00:00:00 2001
From: "Vojtech Vitek (V-Teq)" <vvitek@redhat.com>
Date: Tue, 6 Mar 2012 10:12:14 +0100
Subject: [PATCH] Add `--copy' backward compatibility option

===
WARNING:
This option is not upstream, they don't want to merge it!
===

Description:
Use --copy instead of rename when shuffling files in -i mode.

Examples:
$ sed -i.tmp file
rename("file", "file.tmp")
rename("sedXXX", "file")

$ sed -i.tmp --copy file
open("sedXXX", RO)
open("file", WO)
read("sedXXX") -> write("file")
unlink("sedXXX")
---
 doc/sed.1     |   17 +++++++++++--
 sed/execute.c |   15 ++++++++++-
 sed/sed.c     |   32 ++++++++++++++++++++++---
 sed/sed.h     |    4 +++
 sed/utils.c   |   71 ++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 sed/utils.h   |    1 +
 6 files changed, 128 insertions(+), 12 deletions(-)

diff --git a/doc/sed.1 b/doc/sed.1
index d1d9d22..ec8cd79 100644
--- a/doc/sed.1
+++ b/doc/sed.1
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.28.
-.TH SED "1" "June 2009" "sed version 4.2.1" "User Commands"
+.TH SED "1" "March 2012" "sed version 4.2.1" "User Commands"
 .SH NAME
 sed \- stream editor for filtering and transforming text
 .SH SYNOPSIS
@@ -34,11 +34,22 @@ add the contents of script-file to the commands to be executed
 .HP
 \fB\-\-follow\-symlinks\fR
 .IP
-follow symlinks when processing in place
+follow symlinks when processing in place; hard links
+will still be broken.
 .HP
 \fB\-i[SUFFIX]\fR, \fB\-\-in\-place\fR[=\fISUFFIX\fR]
 .IP
-edit files in place (makes backup if extension supplied)
+edit files in place (makes backup if extension supplied).
+The default operation mode is to break symbolic and hard links.
+This can be changed with \fB\-\-follow\-symlinks\fR and \fB\-\-copy\fR.
+.HP
+\fB\-c\fR, \fB\-\-copy\fR
+.IP
+use copy instead of rename when shuffling files in \fB\-i\fR mode.
+While this will avoid breaking links (symbolic or hard), the
+resulting editing operation is not atomic.  This is rarely
+the desired mode; \fB\-\-follow\-symlinks\fR is usually enough, and
+it is both faster and more secure.
 .HP
 \fB\-l\fR N, \fB\-\-line\-length\fR=\fIN\fR
 .IP
diff --git a/sed/execute.c b/sed/execute.c
index ce584f6..72c63f9 100644
--- a/sed/execute.c
+++ b/sed/execute.c
@@ -818,11 +818,22 @@ closedown(input)
       if (strcmp(in_place_extension, "*") != 0)
         {
           char *backup_file_name = get_backup_file_name(target_name);
-	  ck_rename (target_name, backup_file_name, input->out_file_name);
+          if (copy_instead_of_rename)
+            ck_copy (target_name, backup_file_name, input->out_file_name);
+          else
+            ck_rename (target_name, backup_file_name, input->out_file_name);
+
           free (backup_file_name);
+        }
+
+      if (copy_instead_of_rename)
+        {
+          ck_copy (input->out_file_name, target_name, input->out_file_name);
+          unlink (input->out_file_name);
 	}
+      else
+        ck_rename(input->out_file_name, target_name, input->out_file_name);
 
-      ck_rename (input->out_file_name, target_name, input->out_file_name);
       free (input->out_file_name);
     }
   else
diff --git a/sed/sed.c b/sed/sed.c
index d9a238f..4fff54f 100644
--- a/sed/sed.c
+++ b/sed/sed.c
@@ -75,6 +75,10 @@ bool follow_symlinks = false;
 /* How do we edit files in-place? (we don't if NULL) */
 char *in_place_extension = NULL;
 
+/* Do we use copy or rename when in in-place edit mode? (boolean
+   value, non-zero for copy, zero for rename).*/
+int copy_instead_of_rename = 0;
+
 /* The mode to use to read files, either "rt" or "rb".  */
 char *read_mode = "rt";
 
@@ -131,10 +135,19 @@ Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\
                  add the contents of script-file to the commands to be executed\n"));
 #ifdef ENABLE_FOLLOW_SYMLINKS
   fprintf(out, _("  --follow-symlinks\n\
-                 follow symlinks when processing in place\n"));
+                 follow symlinks when processing in place; hard links\n\
+                 will still be broken.\n"));
 #endif
   fprintf(out, _("  -i[SUFFIX], --in-place[=SUFFIX]\n\
-                 edit files in place (makes backup if extension supplied)\n"));
+                 edit files in place (makes backup if extension supplied).\n\
+                 The default operation mode is to break symbolic and hard links.\n\
+                 This can be changed with --follow-symlinks and --copy.\n"));
+  fprintf(out, _("  -c, --copy\n\
+                 use copy instead of rename when shuffling files in -i mode.\n\
+                 While this will avoid breaking links (symbolic or hard), the\n\
+                 resulting editing operation is not atomic.  This is rarely\n\
+                 the desired mode; --follow-symlinks is usually enough, and\n\
+                 it is both faster and more secure.\n"));
 #if defined(WIN32) || defined(_WIN32) || defined(__CYGWIN__) || defined(MSDOS) || defined(__EMX__)
   fprintf(out, _("  -b, --binary\n\
                  open files in binary mode (CR+LFs are not processed specially)\n"));
@@ -174,9 +187,9 @@ main(argc, argv)
   char **argv;
 {
 #ifdef REG_PERL
-#define SHORTOPTS "bsnrRuEe:f:l:i::V:"
+#define SHORTOPTS "bcsnrRuEe:f:l:i::V:"
 #else
-#define SHORTOPTS "bsnruEe:f:l:i::V:"
+#define SHORTOPTS "bcsnruEe:f:l:i::V:"
 #endif
 
   static struct option longopts[] = {
@@ -188,6 +201,7 @@ main(argc, argv)
     {"expression", 1, NULL, 'e'},
     {"file", 1, NULL, 'f'},
     {"in-place", 2, NULL, 'i'},
+    {"copy", 0, NULL, 'c'},
     {"line-length", 1, NULL, 'l'},
     {"quiet", 0, NULL, 'n'},
     {"posix", 0, NULL, 'p'},
@@ -256,6 +270,10 @@ main(argc, argv)
 	  follow_symlinks = true;
 	  break;
 
+	case 'c':
+	  copy_instead_of_rename = true;
+	  break;
+
 	case 'i':
 	  separate_files = true;
 	  if (optarg == NULL)
@@ -334,6 +352,12 @@ to the extent permitted by law.\n\
 	}
     }
 
+  if (copy_instead_of_rename && in_place_extension == NULL)
+    {
+      fprintf (stderr, _("Error: -c used without -i.\n"));
+      usage(4);
+    }
+
   if (!the_program)
     {
       if (optind < argc)
diff --git a/sed/sed.h b/sed/sed.h
index d657a42..3a25f62 100644
--- a/sed/sed.h
+++ b/sed/sed.h
@@ -232,6 +232,10 @@ extern countT lcmd_out_line_len;
 /* How do we edit files in-place? (we don't if NULL) */
 extern char *in_place_extension;
 
+/* Do we use copy or rename when in in-place edit mode? (boolean
+   value, non-zero for copy, zero for rename).*/
+extern int copy_instead_of_rename;
+
 /* The mode to use to read files, either "rt" or "rb".  */
 extern char *read_mode;
 
diff --git a/sed/utils.c b/sed/utils.c
index 8c009e4..f7a56e2 100644
--- a/sed/utils.c
+++ b/sed/utils.c
@@ -39,6 +39,7 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <limits.h>
+#include <fcntl.h>
 
 #include "utils.h"
 #include "pathmax.h"
@@ -417,14 +418,56 @@ follow_symlink(const char *fname)
 #endif /* ENABLE_FOLLOW_SYMLINKS */
 }
 
+/* Copy a file. */
+static int
+_copy (from, to)
+  const char *from, *to;
+{
+  static char buf[4096];
+
+  FILE *infile, *outfile;
+  int c;
+
+  infile = fopen (from, "r");
+  if (infile == NULL)
+    return -1;
+
+  outfile = fopen (to, "w");
+  if (outfile == NULL)
+    {
+      fclose (infile);
+      return -1;
+    }
+
+  while (1)
+    {
+      size_t bytes_in = fread (buf, 1, sizeof (buf), infile);
+      size_t bytes_out;
+      if (bytes_in == 0)
+       {
+         if (ferror (infile))
+           return -1;
+         break;
+       }
+
+      bytes_out = fwrite (buf, 1, bytes_in, outfile);
+      if (bytes_out != bytes_in)
+        return -1;
+    }
+
+  fclose (outfile);
+  fclose (infile);
+
+  return 0;
+}
+
 /* Panic on failing rename */
 void
 ck_rename (from, to, unlink_if_fail)
   const char *from, *to;
   const char *unlink_if_fail;
 {
-  int rd = rename (from, to);
-  if (rd != -1)
+  if (rename (from, to) != -1)
     return;
 
   if (unlink_if_fail)
@@ -443,9 +486,31 @@ ck_rename (from, to, unlink_if_fail)
   panic (_("cannot rename %s: %s"), from, strerror (errno));
 }
 
+/* Attempt to copy file contents between the files. */
+void
+ck_copy (from, to, unlink_if_fail)
+  const char *from, *to;
+  const char *unlink_if_fail;
+{
+  if (_copy (from, to) != -1)
+    return;
 
+  if (unlink_if_fail)
+    {
+      int save_errno = errno;
+      errno = 0;
+      unlink (unlink_if_fail);
+
+      /* Failure to remove the temporary file is more severe, so trigger it first.  */
+      if (errno != 0)
+        panic (_("cannot remove %s: %s"), unlink_if_fail, strerror (errno));
+
+      errno = save_errno;
+    }
+
+  panic (_("cannot copy %s to %s: %s"), from, to, strerror (errno));
+}
 
-
 /* Panic on failing malloc */
 VOID *
 ck_malloc(size)
diff --git a/sed/utils.h b/sed/utils.h
index d3f431d..2552b76 100644
--- a/sed/utils.h
+++ b/sed/utils.h
@@ -32,6 +32,7 @@ const char *follow_symlink P_((const char *path));
 size_t ck_getline P_((char **text, size_t *buflen, FILE *stream));
 FILE * ck_mkstemp P_((char **p_filename, char *tmpdir, char *base));
 void ck_rename P_((const char *from, const char *to, const char *unlink_if_fail));
+void ck_copy P_((const char *from, const char *to, const char *unlink_if_fail));
 
 VOID *ck_malloc P_((size_t size));
 VOID *xmalloc P_((size_t size));
-- 
1.7.6.5

